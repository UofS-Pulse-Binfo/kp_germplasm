<?php

/**
 * @file
 * The main functionality of this module.
 */

// Initialize fields.
module_load_include('inc', 'germ_summary', 'includes/TripalFields/germ_summary.fields');

/**
 * Implements hook_menu().
 */
function germ_summary_menu() {
  // Home - display a summary matrix showing siblings count under parents.
  $items['germplasm/summary'] = array(
    'title' => 'Germplasm Summary',
    'access arguments' => array('access content'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('germ_summary_form', 2),
    'type' => MENU_NORMAL_ITEM,
  );

  // Menu callback - display number of siblings table. (% - /mom/dad)
  $items['germplasm/list/%/%/%'] = array(
    'title' => 'Germplasm List',
    'access arguments' => array('access content'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('germ_summary_form', 2, 3, 4),
    'type' => MENU_CALLBACK,
  );

  return $items;
}


/**
 * Function callback: Construct matrix and table.
 * NOTE: Show maternal parent then paternal parent when show these information.
 */
function germ_summary_form($form, &$form_state) {
  $args = array();

  $args_genus = ($form_state['build_info']['args'][0] == '' || $form_state['build_info']['args'][0] == 'list')
    ? variable_get('germ_summary_default_genus', germ_summary_get_default_genus())
    : $form_state['build_info']['args'][0];

  // For Lens.
  // Construct species headers for both mom and dad.
  // Get all species and use this to generate headers containing maternal and paternal species.
  $sql = "SELECT organism_id, species FROM {organism} WHERE genus = :genus ORDER BY species ASC";

  // Store the species name and use this to search for no of children
  // in the array generated by the query above.
  $result = chado_query($sql, array(':genus' => $args_genus));

  if ($result->rowCount() > 0) {
    $arr_species = $result
      ->fetchAllKeyed();

    // Put the sps at the end.
    ksort($arr_species, SORT_NUMERIC);

    // Which view mode below to render?
    // Determine parent species if they are in the path. If encoded it shuld be a list the user wants
    // otherwise, load the matrix.
    $display = (isset($form_state['build_info']['args'][1]) AND isset($form_state['build_info']['args'][2]))
      ? 'list' : 'matrix';

    $species_filter = '';
    if ($display == 'list') {
      $mom = $form_state['build_info']['args'][1];
      $dad = $form_state['build_info']['args'][2];

      if (isset($arr_species[ $mom ]) && isset($arr_species[ $dad ])) {
        // Parents check - prepare to fetch the children.
        // @see 2nd query below.
        $args_mom = $arr_species[ $mom ];
        $args_dad = $arr_species[ $dad ];
      }
      else {
        // Does not recognize the parents. Load up the matrix.
        $display = 'matrix';
      }
    }

    // Title and description:
    // Set the title to reflect the current genus.
    // ie. Lens Germplasm Summary.
    drupal_set_title($args_genus . ' Germplasm Summary');
    $form_description = ($display == 'list') ? ''
      : 'The following table summarizes the number of germplasm with parents of
      the specified species. Specifically, the maternal parent species is listed as
      the column header and the paternal parent species is the row header. Thus intraspecific
      crosses are shown along the rest of the table.';

    // Set query arguments.
    $args[':genus']  = $args_genus;
    $args[':is_sel'] = variable_get('gs_var_issel');
    $args[':is_mom'] = variable_get('gs_var_ismom');
    $args[':is_dad'] = variable_get('gs_var_isdad');
    $args[':is_ril'] = variable_get('gs_var_isril');

    // Matrix: we want all count for every cross.
    // List: only the count for a given cross.

    // Names of child returned to show sample when user hovers on a count (first 5).
    // stock_id (in JSON) used expand/show list, the summary count is based on to get precise match.

    // Credits to: Sanderson L-A, kp_searches
    // https://github.com/UofS-Pulse-Binfo/kp_searches
    $sql = "
      SELECT
        COUNT(s.stock_id) num_children,
        CASE WHEN momo.species IS NULL THEN 'sp. (unknown)' ELSE momo.species END AS mom,
        CASE WHEN dado.species IS NULL THEN 'sp. (unknown)' ELSE dado.species END AS dad,

        ARRAY_TO_STRING((ARRAY_AGG(DISTINCT s.name))[1:5], ',') AS stock_names,
        ARRAY_TO_JSON(ARRAY_AGG(s.stock_id)) AS json_stock_id
      FROM {stock} s
        LEFT JOIN {organism} o ON o.organism_id=s.organism_id

        LEFT JOIN {stock_relationship} origcross ON origcross.subject_id = s.stock_id
          AND origcross.type_id = :is_sel
        LEFT JOIN {stock_relationship} momr ON momr.object_id = origcross.object_id
          AND momr.type_id = :is_mom
        LEFT JOIN {stock_relationship} dadr ON dadr.object_id = origcross.object_id
          AND dadr.type_id = :is_dad

        LEFT JOIN {stock} mom ON momr.subject_id = mom.stock_id
        LEFT JOIN {stock} dad ON dadr.subject_id = dad.stock_id
        LEFT JOIN {organism} momo ON momo.organism_id = mom.organism_id
        LEFT JOIN {organism} dado ON dado.organism_id = dad.organism_id
      WHERE s.type_id=:is_ril AND o.genus = :genus
      GROUP BY momo.species, dado.species";

    $result = chado_query($sql, $args);
    // #Debug option: show result set.
    // dpm($args, 'args');
    // dpm($result->fetchAll(), 'results');

    if ($result->rowCount() > 0) {
      $arr_stock_prop = array();

      // Every stock record sort according to the requirement of
      // view mode. For list, we just want the stock id the summary count is base on
      // whereas in matrix we need all but the stock id listing.
      foreach($result as $stock) {
        if ($display == 'list' && $stock->mom == $args_mom && $stock->dad == $args_dad) {
          $arr_stock_prop[$stock->mom][$stock->dad] = $stock->json_stock_id;
          break;
        }
        else {
          $arr_stock_prop[$stock->mom][$stock->dad] = array(
            'count'  => $stock->num_children,
            'sample' => $stock->stock_names
          );
        }
      }

      // RENDER list or matrix.

      // When listing the stocks, we nee this one last query before we can render
      // anything to the frontend.
      if ($display == 'list') {
        $args = array();

        $f = unserialize(variable_get('gs_var_fgens'));
        $args[':F1'] = $f['F1']; $args[':F2'] = $f['F2']; $args[':F3'] = $f['F3']; $args[':F4'] = $f['F4'];
        $args[':F5'] = $f['F5']; $args[':F6'] = $f['F6']; $args[':F7'] = $f['F7']; $args[':F8'] = $f['F8'];
        $args[':RIL_complete'] = $f['RIL_complete'];

        $args[':is_mom'] = variable_get('gs_var_ismom');
        $args[':is_dad'] = variable_get('gs_var_isdad');
        $args[':is_sel'] = variable_get('gs_var_issel');

        $args[':stock_id'] = json_decode($arr_stock_prop[$args_mom][$args_dad]);

        $sql = "
          SELECT
            s.stock_id, s.name, s.type_id, s.uniquename AS accession,
            mom.name || ' (' || mom.uniquename || ')' AS maternal_parent, mom.stock_id AS mom_stock_id, mom.type_id AS mom_type_id,
            dad.name || ' (' || dad.uniquename || ')' AS paternal_parent, dad.stock_id AS dad_stock_id, dad.type_id AS dad_type_id,
            STRING_AGG(
              CASE
                WHEN prop.type_id = :F1 THEN CONCAT('F1=>', TRIM(prop.value))
                WHEN prop.type_id = :F2 THEN CONCAT('F2=>', TRIM(prop.value))
                WHEN prop.type_id = :F3 THEN CONCAT('F3=>', TRIM(prop.value))
                WHEN prop.type_id = :F4 THEN CONCAT('F4=>', TRIM(prop.value))
                WHEN prop.type_id = :F5 THEN CONCAT('F5=>', TRIM(prop.value))
                WHEN prop.type_id = :F6 THEN CONCAT('F6=>', TRIM(prop.value))
                WHEN prop.type_id = :F7 THEN CONCAT('F7=>', TRIM(prop.value))
                WHEN prop.type_id = :F8 THEN CONCAT('F8=>', TRIM(prop.value))
                ELSE ''
              END, ' # ') AS property_generation,
            STRING_AGG(CASE WHEN prop.type_id = :RIL_complete THEN TRIM( prop.value ) END, '') AS property_complete
          FROM {stock} s
            LEFT JOIN {organism} o ON o.organism_id=s.organism_id

            LEFT JOIN {stock_relationship} origcross ON origcross.subject_id=s.stock_id
              AND origcross.type_id = :is_sel
            LEFT JOIN {stock_relationship} momr ON momr.object_id=origcross.object_id
              AND momr.type_id=:is_mom
            LEFT JOIN {stock_relationship} dadr ON dadr.object_id=origcross.object_id
              AND dadr.type_id=:is_dad

            LEFT JOIN {stock} mom ON momr.subject_id=mom.stock_id
            LEFT JOIN {stock} dad ON dadr.subject_id=dad.stock_id
            LEFT JOIN {organism} momo ON momo.organism_id=mom.organism_id
            LEFT JOIN {organism} dado ON dado.organism_id=dad.organism_id

            LEFT JOIN {stockprop} AS prop ON s.stock_id = prop.stock_id
          WHERE s.stock_id IN (:stock_id)
          GROUP BY
            s.stock_id, s.name, s.type_id, s.uniquename,
            mom.name, mom.uniquename, mom.stock_id, mom.type_id,
            dad.name, dad.uniquename, dad.stock_id, dad.type_id
          ORDER BY s.name ASC";

        $result = chado_query($sql, $args);
        // #Debug option: show result set.
        // dpm($result->fetchAll());

        if ($result->rowCount() > 0) {
          // Prepare headers.
          $arr_tbl_headers = array(
            t('Name'), t('Accession'), t('Maternal Parent'), t('Paternal Parent')
          );

          $path = $GLOBALS['base_url'] . '/' . drupal_get_path('module', 'germ_summary') . '/theme/img/';
          for($f = 1; $f <= 9; $f++) {
            if ($f < 9) {
              $img = $path . 'header-f' . $f . '.jpg';
              $alt = 'F' . $f;
            }
            else {
              $img = $path . 'header-finished.jpg';
              $alt = 'RIL Complete';
            }

            $arr_tbl_headers[] = sprintf('<img src="%s" alt="%s" title="%s">', $img, $alt, $alt);
          }

          // At this point header is Name - Accession - Maternal Parent - Paternal Parent F1-8 - RIL Complete.
          // Data rows, fetch each stocks in the result set and fill information in
          // the table headers prepared above.
          $arr_row_cell_value = $arr_tbl_rows =  $arr_entity_id = array();

          foreach($result as $stock) {
            // Name of stock (child), maternal parent and paternal parent are link to
            // a Tripal 3 compatible page usually bio_data/. To obtain path, it will
            // query from entity table for the page id.

            // Keep a record of each stock type in the event same id will appear. In this
            // we will query this array as opposed to querying the database.

            // # STOCK/CHILD:
            if (isset($arr_entity_id[ $stock->stock_id . '-' . $stock->type_id ])) {
              $entity_id = $arr_entity_id[ $stock->stock_id . '-' . $stock->type_id ];
            }
            else {
              $entity_id = germ_summary_fetch_tripalentityid($stock->stock_id, $stock->type_id);
              $arr_entity_id[ $stock->stock_id . '-' . $stock->type_id ] = $entity_id;
            }

            $child = ($entity_id == '#') ? $stock->name : l($stock->name,
              'bio_data/' . $entity_id, array('attributes' => array('target' => '_blank')));
            $child_accession = $stock->accession;

            // # MATERNAL PARENT:
            if (empty($stock->maternal_parent)) {
              $child_mom = 'Unknown';
            }
            else {
              if (isset($arr_entity_id[ $stock->mom_stock_id . '-' . $stock->mom_type_id ])) {
                $entity_id = $arr_entity_id[ $stock->mom_stock_id . '-' . $stock->mom_type_id ];
              }
              else {
                $entity_id = germ_summary_fetch_tripalentityid($stock->mom_stock_id, $stock->mom_type_id);
                $arr_entity_id[ $stock->mom_stock_id . '-' . $stock->mom_type_id ] = $entity_id;
              }

              $child_mom = ($entity_id == '#') ? $stock->maternal_parent : l($stock->maternal_parent,
                'bio_data/' . $entity_id, array('attributes' => array('target' => '_blank')));
            }

            // # PATERNAL PARENT:
            if (empty($stock->paternal_parent)) {
              $child_dad = 'Unknown';
            }
            else {
              if (isset($arr_entity_id[ $stock->dad_stock_id . '-' . $stock->dad_type_id ])) {
                $entity_id = $arr_entity_id[ $stock->dad_stock_id . '-' . $stock->dad_type_id ];
              }
              else {
                $entity_id = germ_summary_fetch_tripalentityid($stock->dad_stock_id, $stock->dad_type_id);
                $arr_entity_id[ $stock->dad_stock_id . '-' . $stock->dad_type_id ] = $entity_id;
              }

              $child_dad = ($entity_id == '#') ? $stock->paternal_parent : l($stock->paternal_parent,
                'bio_data/' . $entity_id, array('attributes' => array('target' => '_blank')));
            }

            $arr_row_cell_value =  array($child, $child_accession, $child_mom, $child_dad);

            $F_property = explode(' # ', $stock->property_generation);
            $arr_fgen = array();

            foreach($F_property as $F) {
              list($F_gen, $F_val) = explode('=>', $F);
              $arr_fgen[$F_gen] = $F_val;
            }

            for($f = 1; $f < 9; $f++) {
              $F = 'F' . $f;

              $F_val = isset($arr_fgen[$F]) ? $arr_fgen[$F] : null;
              $arr_row_cell_value[] = germ_summary_generate_cell_value($F_val, $F);
            }

            // Create the cell value for RIL complete.
            $arr_row_cell_value[] = germ_summary_generate_cell_value($stock->property_complete, 'RIL');

            // All in
            array_push($arr_tbl_rows, $arr_row_cell_value);
          }

          // No more need for the ids.
          unset($arr_entity_id);

          // Pager:
          // Number of rows per page.
          $pager_rows_per_page = 25;
          // Current page number in pager.
          $pager_current_page = pager_default_initialize(count($arr_tbl_rows), $pager_rows_per_page);
          // Show the rows for a page number.
          $pager_row_set = array_chunk($arr_tbl_rows, $pager_rows_per_page, TRUE);

          $sum_table = germ_summary_construct_table($arr_tbl_headers, $pager_row_set[$pager_current_page], 'tbl-summary-table');

          // Add another table header to contain header for generations and finished property.
          // 3 columns 1 row - first col empty (Stock info) 2nd col Generations 3rd col empty (Finished property).
          $sum_table = str_replace('<thead>',
            '<thead>
              <tr class="headings">
                <th colspan="4">&nbsp;</th>
                <th colspan="8">Generations</th>
                <th>&nbsp</th>
              </tr>
            ', $sum_table);

          $form['back_link'] = array(
            '#type' => 'markup',
            '#markup' => l('Back to Summary Matrix', 'germplasm/summary/' . $args_genus),
          );

          $form['summary_table'] = array(
            '#markup' => $sum_table . theme('pager', array('quantity', count($arr_tbl_rows))),
          );

          // Summary table title information.
          // Sibling count.
          $form['siblings_count'] = array(
            '#type' => 'hidden',
            '#value' => count($arr_tbl_rows),
          );

          // Mommy's name.
          $form['siblings_mom'] = array(
            '#type' => 'hidden',
            '#value' => $args_mom,
          );

          // Dad's name.
          $form['siblings_dad'] = array(
            '#type' => 'hidden',
            '#value' => $args_dad,
          );
        }
        else {
          // 0 children for this pair.
          drupal_set_message('There are no RILs for this combination of species.', 'warning');
        }
      }
      else {
        $i = 1;

        // Traverse the result set and organize the species to go vertically (dad) and on each
        // pass construct the horizontal (mom) items.
        // Dad1 - Mom1, Mom2, Mom3, Mom4
        // Dad2 - Mom1, Mom2, Mom3, Mom4 ...

        $arr_tbl_rows = array();
        $tmp_rows = array();
        // Arrays to hold table headers and rows.
        $arr_tbl_headers = array();
        // Push a blank cell to account for the corner cell in the summary. Cornermost, cell.
        $arr_tbl_headers[0] = '&nbsp;';

        foreach($arr_species as $dad_key => $dad_species) {
          // Sanitize the species for use as a class name.
          // DAD:
          $class = preg_replace('/[^-\w]+/', '', str_replace(' ', '-', strtolower($dad_species)));
          $dad_header = '<div><span>' . trim($dad_species) . '</span></div>';

          // With this dad header, create the mom header. This will create the dad = mom (same as the current dad's name).
          array_push($arr_tbl_headers, array('data' => $dad_header, 'id' => 'maternal-' . $i, 'class' => array($class)));

          // This the dad header.
          $tmp_rows = array(array('header' => true, 'data' => $dad_header, 'id' => 'paternal-' . $i, 'class' => array($class)));

          // Construct cell plus the count for this couple as well as other mom match to this current dad.
          $j = 1;

          foreach($arr_species as $mom_key => $mom_species) {
            if (isset($arr_stock_prop[ $mom_species ][ $dad_species ]['count'])) {
              // Has child. create a link so this summary count is link.
              $child_count = l($arr_stock_prop[ $mom_species ][ $dad_species ]['count'], 'germplasm/list/' . $args_genus . '/' . $mom_key . '/' . $dad_key);
              $names = explode(',', $arr_stock_prop[ $mom_species ][ $dad_species ]['sample']);
            }
            else {
              // 0, no child.
              $child_count = '<span style="color:#E6E6E6">0</span>';
              $names = '';
            }

            // Create a cell.
            $parents = '[' . $mom_species . ' x ' . $dad_species . ']';
            $title = ($names) ? $parents . "\n" . implode("\n", $names) . "\n..." : $parents;

            array_push($tmp_rows, array('data' => $child_count, 'id' => 'p-' . $j . '-' . $i, 'title' => $title));

            // Next mom same dad.
            $j++;
          }

          // Create the row.
          array_push($arr_tbl_rows, $tmp_rows);

          // Nex dad.
          $i++;
        }

        // Create the matrix table.
        $form['summary_matrix'] = array(
          '#markup' => germ_summary_construct_table($arr_tbl_headers, $arr_tbl_rows, 'tbl-summary-matrix'),
        );
      }

      $path = drupal_get_path('module', 'germ_summary') . '/theme/';
      $form['#attached']['css'] = array($path . 'css/germ_summary.style.css');
      $form['#attached']['js']  = array($path . 'js/germ_summary.script.js');

      // @see above.
      $form['description'] = array(
        '#type' => 'item',
        '#markup' => $form_description,
      );
    }
    else {
      $num_rils = chado_query("SELECT count(*) FROM {stock} WHERE type_id=:type", [':type' => variable_get('gs_var_isril', NULL)])->fetchField();
      if ($num_rils > 0) {
        drupal_set_message("The RILs available for this genus are not associated with a corresponding original stock. Ensure you have a Breeding Cross related to each RIL via a 'stock_relationship:is_selected_from' relationship.", 'warning');
      }
      else {
        drupal_set_message('There are no RILs available for this genus. Go to Content > Tripal Content > Recombinant Inbred Line to create one.', 'warning');
      }
    }
  // End has species.
  }
  else {
    // Has no species - could be hacked genus in the url.
    drupal_set_message('Genus not found.', 'warning');
  }

  return $form;
}


/**
 * Implements hook_theme().
 */
function germ_summary_theme($existing, $type, $theme, $path) {
  $items['germ_summary_form'] = array(
    'render element' => 'form',
    'template' => 'germ_summary_matrix',
    'path' => $path . '/theme',
  );

  return $items;
}


/**
 * Helper Function: Determine the default genus.
 *
 * We're going to assume that the genus with the most species is the one they want...
 * If two genus' have the same number of species then the default is chosen aphabetically.
 *
 * @return
 *   The genus to use as the default.
 */
function germ_summary_get_default_genus() {
  // Grab the genus with the most species.
  $genus = chado_query('
    SELECT t.genus
    FROM (
        SELECT genus, count(*) as num_species
        FROM {organism}
        GROUP BY genus
      ) t
    ORDER BY t.num_species DESC, t.genus ASC
    LIMIT 1
  ')->fetchField();

  // If that worked then save it for faster use later.
  if ($genus) {
    variable_set('germ_summary_default_genus', $genus);
  }

  return $genus;
}


/**
 * Function helper: Construct a Drupal theme table.
 *
 * @param $headers
 *   An array containing the headers of the table.
 * @param $rows
 *   An array containing the rows of the table.
 * @param $tbl_id
 *   A string containing the id attribute of the table.
 *
 * @return
 *   Drupal theme table.
 */
function germ_summary_construct_table($headers, $rows, $tbl_id) {
  // Array to Hold Drupal Table properties.
  $arr_tbl_args = array();

  $arr_tbl_args['header']     = $headers;
  $arr_tbl_args['rows']       = $rows;
  $arr_tbl_args['sticky']     = ($tbl_id == 'tbl-summary-table') ? FALSE : TRUE;
  $arr_tbl_args['attributes'] = array('id' => $tbl_id);

  return theme('table', $arr_tbl_args);
}


/**
 * Function helper: Generete the correct value to a table cell given a Stock Property Value.
 *
 * @param $prop_value
 *   The value of a given Stock Property.
 * @param $prop_type
 *   The type of stock property of a given property value.
 *   RIL - for RIL complete
 *   F%  - for F1 - F8 generation
 *
 * @return
 *   Exists but empty: Check icon (image).
 *   Exists but has value: Display the value (text/numeric).
 *   Does not exist: Blank space.
 */
function germ_summary_generate_cell_value($prop_value, $prop_type) {
  if (isset($prop_value)) {
    if ($prop_value == '') {
      // Check mark image icon.
      $attr_image = '../../../../' . drupal_get_path('module', 'germ_summary') . '/theme/img/message-16-ok.png';
      // Alternate text (alt/title) attribute of the icon image.
      $attr_title = ($prop_type == 'RIL') ? 'RIL Complete' : 'Generation ' . $prop_type;

      $cell_val = '<img src="' . $attr_image . ' " alt="' . $attr_title . '" title="' . $attr_title . '" />';
    }
    else {
      $cell_val = $prop_value;
    }
  }
  else {
    $cell_val = '&nbsp;';
  }

  return $cell_val;
}


/**
 * Fetch entity id that will form part of the url linking to Tripal 3 germplasm page.
 *
 * @param $stock_id
 *   Integer, stock id number corresponding to stock_id field in chado.stock table.
 * @param $stock_type
 *   Integer, type id number corresponding to type_id field in chado.stock table.
 *
 * @return Integer
 *   Chado entity id number that forms part of the url linking to Tripal 3 page or # null page.
 */
function germ_summary_fetch_tripalentityid($stock_id, $stock_type) {
  if ($stock_id > 0 && $stock_type > 0) {
    // Fetch entity id that will form part of the url linking to Tripal 3 germplasm page.
    $chado_bundle = db_query('SELECT t2.name FROM {tripal_term} AS t1 INNER JOIN {tripal_bundle} AS t2 ON t1.id = t2.term_id
      WHERE t1.accession = (SELECT t3.accession FROM chado.dbxref AS t3 INNER JOIN chado.cvterm AS t4 USING(dbxref_id)
        WHERE t4.cvterm_id = :stock_type)', array(':stock_type' => $stock_type))
      ->fetchField();

    if ($chado_bundle) {
      $entity = sprintf("SELECT entity_id FROM chado_%s WHERE record_id = :stock_id LIMIT 1", $chado_bundle);
      $chado_entity = chado_query($entity, array(':stock_id' => $stock_id))
        ->fetchField();
    }
    else {
      tripal_report_error('germ_summary', TRIPAL_WARNING, 'Unable to find bundle for :bundle.', [':bundle' => $stock_type]);
    }
  }

  return $chado_entity ?? '#';
}
